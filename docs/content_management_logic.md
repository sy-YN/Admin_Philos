# 解説：コンテンツ管理画面は、なぜ安定して表示されるのか？

このドキュメントは、現在の「コンテンツ管理」画面が、権限エラーを起こさずに安定して表示されるまでの裏側の処理の流れ（ロジック）を、3つのステージに分けて詳しく解説します。

ユーザー様の「まずコンテンツ本体（親）のリストだけを取得し、後から詳細（子）を取得しているからでは？」というご推察は、まさしくその通りです。この「段階的読み込み」が、安定動作の 핵심（かくしん）となっています。

---

## 全体像：3段階の「関所」を突破するロード処理

コンテンツ管理画面が表示されるまでには、アプリケーション内部で以下の3つのステージが順番に実行されます。前のステージをクリアしない限り、次のステージへは進みません。これにより、権限が不確かな状態でのデータアクセスを完全に防いでいます。

```mermaid
graph TD
    A[ステージ1: 認証・権限チェック] --> B[ステージ2: メインコンテンツ取得];
    B --> C[ステージ3: 詳細データ取得 (オンデマンド)];
    
    subgraph "A (レイアウト層)"
        A_1["ユーザーは誰か？<br>どんな権限を持っているか？<br><b>(DashboardLayout, PermissionProvider)</b>"]
    end
    
    subgraph "B (ページ層)"
        B_1["権限OKなら、ビデオやメッセージの<br><b>リストだけ</b>を取得<br><b>(ContentsPage)</b>"]
    end
    
    subgraph "C (ダイアログ層)"
        C_1["ユーザーがCountsをクリックしたら、<br><b>初めて</b>コメントやいいねを取得<br><b>(ContentDetailsDialog)</b>"]
    end

    A_1 --> A
    B_1 --> B
    C_1 --> C
```

---

### ステージ1：認証・権限チェック (門番)

-   **担当コンポーネント**: `src/app/dashboard/layout.tsx` (`LayoutAuthWrapper`), `src/context/PermissionContext.tsx`
-   **役割**: ユーザーが誰で、何をする権限を持っているのかを**最優先で**確定させます。

**▼ 処理の流れ**

1.  ユーザーが `/dashboard/contents` にアクセスすると、まず親の `DashboardLayout` が起動します。
2.  `LayoutAuthWrapper` が「待った！」をかけ、子要素（`ContentsPage`）の**レンダリングを一時停止**します。画面にはローディングスピナーが表示されます。
3.  内部の `PermissionProvider` が、Firebaseと通信し、以下の2つを非同期で取得します。
    *   ユーザーはログインしているか？ (`useUser`)
    *   ログインしているなら、そのユーザーの権限（`permissions`）は何か？
4.  権限情報（例: `['video_management', 'can_comment']`）が完全に取得できるまで、`isCheckingPermissions` は `true` のままです。
5.  権限が確定し、`isCheckingPermissions` が `false` になった瞬間に、`LayoutAuthWrapper` は「通行許可！」を出し、初めて子要素である `ContentsPage` のレンダリングを開始します。

> **ポイント**: このステージがあるおかげで、「権限情報が不明なまま、次のデータ取得処理に進んでしまう」という根本的な競合状態（レースコンディション）が解消されました。

---

### ステージ2：メインコンテンツ取得 (一覧表示)

-   **担当コンポーネント**: `src/app/dashboard/contents/page.tsx`
-   **役割**: ステージ1で確定した権限に基づき、安全なクエリを発行して、ビデオやメッセージの**一覧データのみ**を取得します。

**▼ 処理の流れ**

1.  `LayoutAuthWrapper` からレンダリングが許可されると、`ContentsPage` が表示処理を開始します。
2.  このコンポーネントは、ステージ1で取得済みの権限情報（`userPermissions`）を即座に利用できます。
3.  `useMemoFirebase` と `useCollection` フックを使い、権限に応じたFirestoreクエリを構築します。
    *   **例1: `video_management` 権限がある場合**
        *   `query(collection(firestore, 'videos'))` というクエリが発行され、`videos`コレクションの**全てのドキュメント**を取得します。
    *   **例2: `proxy_post_video` 権限のみの場合**
        *   `query(collection(firestore, 'videos'), where('creatorId', '==', currentUser.uid))` というクエリが発行され、自分が作成したビデオのドキュメント**のみ**を取得します。
    *   **例3: 権限が何もない場合**
        *   `query(collection(firestore, 'videos'), where('creatorId', '==', 'NO_ONE_HAS_THIS_ID'))` という、意図的に**結果が0件になる**クエリが発行され、不要な読み取りとエラーを防ぎます。
4.  この段階では、`videos` や `executiveMessages` といった**親コレクションのドキュメント**（タイトル、投稿者ID、`likesCount`など）のみが取得されます。`comments` や `likes` といった**サブコレクションの中身は一切取得しません。**
5.  取得した一覧データが、`VideosTable` や `MessagesTable` コンポーネントに渡され、画面に表示されます。

> **ポイント**: Firestoreのクエリは、デフォルトではサブコレクションのデータを一緒に取得しません。この「浅い（shallow）」読み取りの性質を利用することで、一覧表示に必要な最小限のデータだけを高速かつ安全に取得しています。

---

### ステージ3：詳細データ取得 (オンデマンド)

-   **担当コンポーネント**: `src/components/contents/content-details-dialog.tsx`
-   **役割**: ユーザーが特定のアクション（クリック）を起こした時に、**初めて**詳細データ（コメント、いいね）を取得します。

**▼ 処理の流れ**

1.  ユーザーが、一覧テーブルの行にある「Counts」（いいね数やコメント数が表示されている部分）をクリックします。
2.  `ContentDetailsDialog` コンポーネントが、ダイアログ（ポップアップウィンドウ）として表示されます。
3.  このダイアログが表示された**後で**、内部の `CommentsList` や `LikesList` コンポーネントがレンダリングを開始します。
4.  これらのコンポーネントは、`useSubCollection` という専用フックを使い、特定のコンテンツ（例: `videos/{videoId}`）に紐づく**サブコレクション**（`comments` や `likes`）のデータを取得するクエリを発行します。
5.  取得されたコメントや「いいね」したユーザーの一覧が、ダイアログ内に表示されます。

> **ポイント**: この「オンデマンド（要求があった時だけ）」の仕組みにより、最初の一覧表示が高速になるだけでなく、「権限がないのにサブコレクションを読み込もうとしてエラーになる」という事態を完全に回避しています。

---

## まとめ

現在のロジックは、以下の原則に基づいています。

1.  **認証ファースト**: 何よりも先に「あなたは誰か？」を確定させる。
2.  **権限ベースのクエリ**: 確定した権限に基づいて、見ることを許された範囲のデータだけを要求する。
3.  **遅延読み込み（Lazy Loading）**: 最初は必要最小限の一覧データだけを取得し、重たい詳細データはユーザーが必要とした時に初めて取得する。

この堅牢な段階的処理によって、アプリケーションの安定性とセキュリティが両立されています。
